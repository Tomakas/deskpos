# Implementation Plan: `activeBillId` on Registers

## Goal
The customer display should show whichever bill the cashier is currently viewing/editing on the POS — whether in ScreenSell or DialogBillDetail. This requires persisting `activeBillId` on the register so it syncs cross-device.

---

## File Changes (ordered by dependency)

### 1. Drift Table — `lib/core/database/tables/registers.dart`
Add after `boundDeviceId`:
```dart
TextColumn get activeBillId => text().nullable()();
```

### 2. Regenerate Drift code
```bash
dart run build_runner build --delete-conflicting-outputs
```

### 3. RegisterModel — `lib/core/data/models/register_model.dart`
Add after `boundDeviceId`:
```dart
String? activeBillId,
```

### 4. Regenerate freezed code (same build_runner command)

### 5. Entity Mapper — `lib/core/data/mappers/entity_mappers.dart`
In `registerFromEntity`, add after `boundDeviceId: e.boundDeviceId,`:
```dart
activeBillId: e.activeBillId,
```

### 6. Supabase Push Mapper — `lib/core/data/mappers/supabase_mappers.dart`
In `registerToSupabaseJson`, add after `'bound_device_id': m.boundDeviceId,`:
```dart
'active_bill_id': m.activeBillId,
```

### 7. Supabase Pull Mapper — `lib/core/data/mappers/supabase_pull_mappers.dart`
In the `'registers'` case, add after `boundDeviceId`:
```dart
activeBillId: Value(json['active_bill_id'] as String?),
```

### 8. RegisterRepository — `lib/core/data/repositories/register_repository.dart`

#### a) Add `watchById` method (needed by customer display):
```dart
Stream<RegisterModel?> watchById(String registerId) {
  return (_db.select(_db.registers)
        ..where((t) => t.id.equals(registerId)))
      .watchSingleOrNull()
      .map((e) => e == null ? null : registerFromEntity(e));
}
```

#### b) Add `setActiveBill` method:
```dart
Future<void> setActiveBill(String registerId, String? billId) async {
  final now = DateTime.now();
  await (_db.update(_db.registers)..where((t) => t.id.equals(registerId)))
      .write(RegistersCompanion(
    activeBillId: Value(billId),
    updatedAt: Value(now),
  ));
  final entity = await (_db.select(_db.registers)
        ..where((t) => t.id.equals(registerId)))
      .getSingleOrNull();
  if (entity != null) {
    await _enqueue('update', registerFromEntity(entity));
  }
}
```

#### c) Update the `update()` method to include `activeBillId`:
In the `RegistersCompanion` write block, add:
```dart
activeBillId: Value(model.activeBillId),
```

### 9. ScreenSell — `lib/features/sell/screens/screen_sell.dart`

#### a) In `initState()`, after `_loadCustomerName()`, set the active bill:
```dart
@override
void initState() {
  super.initState();
  _loadCustomerName();
  _setActiveBill();
}
```

#### b) Add `_setActiveBill()` method:
```dart
void _setActiveBill() {
  if (widget.billId == null) return;
  final register = ref.read(activeRegisterProvider).value;
  if (register != null) {
    ref.read(registerRepositoryProvider).setActiveBill(register.id, widget.billId);
  }
}
```

#### c) In `dispose()`, clear the active bill:
```dart
@override
void dispose() {
  _clearActiveBill();
  _debounce?.cancel();
  _searchController.dispose();
  super.dispose();
}

void _clearActiveBill() {
  final register = ref.read(activeRegisterProvider).value;
  if (register != null) {
    ref.read(registerRepositoryProvider).setActiveBill(register.id, null);
  }
}
```

**Quick sale handling:** When `billId` is null (quick sale), we don't set activeBillId during initState. But after the quick bill is *created* (during _submitOrder), we should set it. Actually — for quick sale, the bill is created and immediately submitted, so the display would flash briefly. The user specifically said "quick bill OR saved bill" — so we should also handle the quick bill case. BUT: quick bills are created inside `_submitOrder` and the screen navigates away right after. There's no point setting activeBillId for a flash. Let me reconsider...

Actually, the user said the customer display should show the bill being "marked" (rung up). For quick sale, items are being added to the cart but the bill doesn't exist yet until submit. So for quick sale, activeBillId stays null (no bill to show). This is correct behavior — the customer display stays idle until a real bill exists.

### 10. DialogBillDetail — `lib/features/bills/widgets/dialog_bill_detail.dart`

The bill detail is a dialog (not a routed screen). When it opens, we should set activeBillId. When it closes, we should clear it.

In `_DialogBillDetailState`:
```dart
@override
void initState() {
  super.initState();
  _setActiveBill();
}

@override
void dispose() {
  _clearActiveBill();
  super.dispose();
}

void _setActiveBill() {
  final register = ref.read(activeRegisterProvider).value;
  if (register != null) {
    ref.read(registerRepositoryProvider).setActiveBill(register.id, widget.billId);
  }
}

void _clearActiveBill() {
  final register = ref.read(activeRegisterProvider).value;
  if (register != null) {
    ref.read(registerRepositoryProvider).setActiveBill(register.id, null);
  }
}
```

NOTE: When the user taps "Order" in the bill detail (which navigates to ScreenSell), the dialog closes (dispose clears activeBillId) and then ScreenSell mounts (initState sets activeBillId). This sequence is correct — there may be a brief null flash between the two, but the StreamBuilder on the customer display will handle it gracefully.

### 11. ScreenCustomerDisplay — `lib/features/sell/screens/screen_customer_display.dart`

The `_ActiveDisplay` widget currently uses `watchOpenByRegister`. It should instead:
1. Watch the register by ID to get `activeBillId`
2. When `activeBillId` is non-null, watch that bill by ID
3. When null, show idle display

Replace `_ActiveDisplay`:
```dart
class _ActiveDisplay extends ConsumerWidget {
  const _ActiveDisplay({required this.registerId});
  final String registerId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final company = ref.watch(currentCompanyProvider);

    return StreamBuilder<RegisterModel?>(
      stream: ref.watch(registerRepositoryProvider).watchById(registerId),
      builder: (context, regSnap) {
        final register = regSnap.data;
        final activeBillId = register?.activeBillId;

        if (activeBillId == null) {
          return _IdleDisplay(companyName: company?.name ?? '');
        }

        return _BillDisplay(billId: activeBillId);
      },
    );
  }
}
```

Extract the bill display into a new `_BillDisplay` widget (essentially the old `_ActiveDisplay` body that watches a bill by ID):
```dart
class _BillDisplay extends ConsumerWidget {
  const _BillDisplay({required this.billId});
  final String billId;
  // ... same StreamBuilder<BillModel?> using watchById(billId) as before
}
```

### 12. Remove `watchOpenByRegister` from BillRepository
Since we no longer need it (the customer display uses `activeBillId` from the register, not a query for open bills).

---

## Files Modified Summary
1. `lib/core/database/tables/registers.dart` — add `activeBillId` column
2. `lib/core/data/models/register_model.dart` — add `activeBillId` field
3. `lib/core/data/mappers/entity_mappers.dart` — map `activeBillId`
4. `lib/core/data/mappers/supabase_mappers.dart` — push `active_bill_id`
5. `lib/core/data/mappers/supabase_pull_mappers.dart` — pull `active_bill_id`
6. `lib/core/data/repositories/register_repository.dart` — add `watchById`, `setActiveBill`, update `update()`
7. `lib/core/data/repositories/bill_repository.dart` — remove `watchOpenByRegister`
8. `lib/features/sell/screens/screen_sell.dart` — set/clear activeBillId on mount/dispose
9. `lib/features/bills/widgets/dialog_bill_detail.dart` — set/clear activeBillId on mount/dispose
10. `lib/features/sell/screens/screen_customer_display.dart` — watch register's activeBillId

## Edge Cases
- **Quick sale (billId == null):** activeBillId not set → customer display stays idle. Correct.
- **Bill detail → Order (navigate to ScreenSell):** Dialog dispose clears, ScreenSell initState sets. Brief null flash handled by StreamBuilder.
- **Bill paid/cancelled in ScreenSell:** User navigates away → dispose clears activeBillId → customer display shows idle.
- **Multiple devices on same register:** LWW applies. Last device to set activeBillId wins. This is correct — the latest action is what matters.
- **App crash/force quit:** activeBillId stays set (stale). Not a problem — it just shows the last active bill until another action clears it.
- **Sync conflict:** activeBillId is just a field on the register row. LWW handles it like any other field.
